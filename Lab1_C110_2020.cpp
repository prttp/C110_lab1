/*************************************************************
	Практическое занятие №1. Встроенные многомерные массивы.
							Динамическое выделение памяти.
							Простейшие алгоритмы сортировки и поиска.
							Сложные указатели.
							Ссылки.
*************************************************************/

#define	  stop __asm nop
#include<string.h>
#include<iostream>
#include <ctime>
int main()
{
	{

		///////////////////////////////////////////////////////////////
		//			Встроенные  многомерные массивы                               //
		///////////////////////////////////////////////////////////////
		/*
			//Задание 1.
			//Объявите трехмерный N*M*K массив и сформируйте указанные
			//значения элементов следующим образом:
			//а) проинициализируйте массив при объявлении */
		const int N = 3;
		const int M = 3;
		const int K = 3;
		int arr1a[N][M][K] = { { {1, 1, 1},
								{1, 1, 1},
								{1, 1, 1}, }, { {2, 2, 2},
												{2, 2, 2},
												{2, 2, 2}, }, { {3, 3, 3},
																{3, 3, 3},
																{3, 3, 3}, } };
		stop
			//б) объявите неинициализированный массив и присвойте значения элементам
			//	с помощью кода
			//					 |--------|		
			//				   / |3  3  3 |		
			//    			 |---------|3 |
				//		   / | 2  2  2 |3 |
			//			  |---------|2 |__|
			//			  | 1  1  1 |2 | /
			//			  | 1  1  1 |__| 
			//			  | 1  1  1 | /
			//			  |_________|
			//Рекомендация: В качестве размерностей массива лучше указать N, M, K,
			//а не  задавать их жестко.  
			//Средствами отладчика проверьте правильность Вашего решения. 
			//Или выведите содержимое массива на печать.
			// Удобно выводить построчно каждый слой  массива и 
			//после каждого слоя пропускать строку для того, чтобы отделить один слой от другого
			int arr1b[N][M][K];
		int* parr1b = &arr1b[0][0][0];
		for (size_t i = 0; i < (sizeof(arr1b) / sizeof(arr1b[0][0][0])); i++) {
			/*if (i / (M * K) < 1) {
				*(parr1b + i) = 1;
				continue;
				};
			if (i / (M * K) < 2) {
				*(parr1b + i) = 2;
				continue;
				};
			if (i / (M * K) < 3) {
				*(parr1b + i) = 3;
				continue;
				};*/
			* (parr1b + i) = i / (M * K) + 1;
		}
		stop
			///в) найдите сумму элементов массива. Подумайте, как это сделать эффективно.
			int sum = 0;
		for (size_t i = 0; i < (sizeof(arr1b) / sizeof(arr1b[0][0][0])); i++) {
			sum += *(parr1b + i);
		};
		stop
			//г) проинициализируйте массив при определении:
			//				     |--------|		
			//			       / |3  0  0 |		
			//      		 |---------|0 |
			//    		   / | 2  0  0 |0 |
			//			  |---------|0 |__|
			//			  | 1  0  0 |0 | /
			//			  | 0  0  0 |__| 
			//			  | 0  0  0 | /
			//			  |_________|

			int arr1g[N][M][K] = { {{1}}, {{2}}, { {3} } };
		stop

			//д) Инициализация массивов строковыми литералами:
			//Объявите и проинициализируйте строковыми литералами два массива:
			//двухмерный массив и массив указателей. Поясните разницу в использовании
			//элементов таких массивов.
			char arr1d1[3][10] = { "one", "two", "three" }; // можно работать с символами по отдельности, т.к. 1 символ - 1 элемент массива
		const char* arr1d2[3] = { "one", "two", "three" }; // нельзя, конст
		stop}
		/////////////////////////////////////////////////////////////////////
		//Задание 2.
		//С помощью данной заготовки напишите программу,которая:
		//вводит строки с клавиатуры с помощью cin>>...
		//в объявленный Вами двухмерный ВСТРОЕННЫЙ массив 10*80 элементов типа char;
		//признаком конца ввода является символ * (то есть строка - "*") или
		//заполнение всего массива (больше свободных строк нет);

		//То есть:
			//a) можно заполнять весь массив полностью (не забудьте подсказать, сколько элементов в массиве)
			//б) можно заполнять массив частично, до тех пор, пока пользователь не ввел строку "*".
			//Например:вводим строки (строки с пробелами не задаются, т.к. пробелы являются разделителями):
			//"Hello"
			//"Ok"
			//"*"
		//сортировка строк в алфавитном порядке. 
		//Пояснение: крайне не рекомендуется для сортировки сложных объектов физически
		//перемещать их в памяти ( в нашем случае перемещать (копировать) строки)
		//Намного эффективнее завести массив указателей на соответствующие строки 
		//и перемещать только указатели на начало строк (массивов символов).
		//Вопрос: При таком способе что будет  отсортировано?

		//Подсказка: для лексикографического сравнения строк пользуйтесь
		//функцией стандартной библиотеки strcmp(...), заголовочный файл <string.h>.
		//int strcmp(char const* _Str1, char const* _Str2);

			// далее Вам предлагается алгоритм, следуя которому, Вы сможете решить задачу.
	{

		//Определите необходимые значения как константы
		char STOP_STRING = '*';	//признак "прекратить ввод"
		const int M = 80;	//максимальный размер одной строки
		const int N = 10;	//максимальное количество строк в массиве
		



		//Объявите двухмерный массив с именем cBuffer типа char и
		// размерностью N*M
		char cBuffer[N][M] = { {0} };
		char (*pcBuffer)[M] = cBuffer;
		//Объявите массив (с именем cPointers) указателей на строки
		//размерностью N
		char* cPointers[N] = { 0 };
		int i = 0;
		do {
			char Input[M] = { 0 };
			//Цикл ввода строк:
			//а) выведите приглашение для ввода
			std::cout << "Please enter the next word and press ENTER" << std::endl;
			//б) пока не введена строка STOP_STRING или не заполнен весь массив
			std::cin >> Input;
			
			if (Input[0] == STOP_STRING) { break; };
			//ввод строки в массив cBuffer:
			memcpy(*(pcBuffer + i), Input, sizeof(*(pcBuffer + i)));
			//если введена строка - признак окончания, то выйти из цикла

			//Присвойте элементу массива cPointers с индексом nIndex
			//указатель на строку с номером nIndex в массиве cBuffer
			cPointers[i] = &cBuffer[i][0];

			i++;
		} while ((i < N));
		//Выдать диагностику о том, что прием строк завершен.
		stop
		std::cout << "The array is full!" << std::endl;

		//Теперь сортируем строки:

	//Цикл сортировки строк по методу "всплывающего пузырька" в
	//порядке возрастания кода первого символа
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < (N- 1); j++) {
				if (cPointers[j + 1] == 0) { break; }
				int res = strcmp(cPointers[j], cPointers[j + 1]);
				if (res > 0 ) {
					char* bcPointers = cPointers[j]; // создали дополнительную переменную
					cPointers[j] = cPointers[j+1]; // меняем местами
					cPointers[j + 1] = bcPointers; // значения элементов
				}
			}
		}
	stop
		for (int i = 0; i < N; i++) {
			if (cPointers[i] == 0) { break; }
			std::cout << cPointers[i] << std::endl;
		}
	}
//////////////////////////////////////////////////////////////////////////////

//Задание 3*. Объявление и использование указателей на многомерные
// массивы. Проинициализируйте трехмерный массив
//double dArray[4][3][3] так, как показано на рисунке и напишите фрагмент
//кода, который меняет местами значения элементов четных
//и нечетных слоев:
//	было:			     |--------|
//  				   / |4  4  4 |
//				     |--------| 4 |
//			       / |3  3  3 | 4 |
//    			 |---------|3 |   |
//			   / | 2  2  2 |3 | /
//			  |---------|2 |__|
//			  | 1  1  1 |2 | /
//			  | 1  1  1 |__|
//			  | 1  1  1 | /
//			  |_________|

//	стало:			     |--------|
//  				   / |3  3  3 |
//				     |--------| 3 |
//			       / |4  4  4 | 3 |
//    			 |---------|4 |   |
//			   / | 1  1  1 |4 | /
//			  |---------|1 |__|
//			  | 2  2  2 |1 | /
//			  | 2  2  2 |__|
//			  | 2  2  2 | /
//			  |_________|
	{
		double dArray[4][3][3];
	double* pdArray = &dArray[0][0][0];
	for (size_t i = 0; i < (sizeof(dArray) / sizeof(dArray[0][0][0])); i++) {
		*(pdArray + i) = i / (3 * 3) + 1;
	}
	double(*pdArray2)[3][3] = &dArray[0];
	for (int j = 0; j < 4; j=j+2)
	{
		//Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА РАВЕНСТВА!!!
		double bpdArray[3][3];
		memcpy(bpdArray, *(pdArray2 + j), sizeof(*(pdArray2 + j)));
		memcpy(*(pdArray2 + j), *(pdArray2 + j + 1), sizeof(*(pdArray2 + j)));
		memcpy(*(pdArray2 + j + 1), bpdArray, sizeof(*(pdArray2 + j+1)));
		 


	//Подсказки: 
	//1) Слева от знака равенства надо определить два  сложных указателя. 
	//Так как справа находятся "имена" слоев, т.е. двумерных массивов, то
	// остается вспомнить какой указатель является эквивалентным имени двумерного массива.

	//2)дальше, воспользовавшись этими указателями, переставляем местами элементы i-того и i+1-ого слоев


	}

	}
///////////////////////////////////////////////////////////////////////////

//Задание 4
//а) Объявите двухмерный ВСТРОЕННЫЙ массив элементов типа char.
//Сформируйте значения элементов массива с помощью генератора случайных
//чисел таким образом, чтобы в массиве были только символы '_' и '*'
	{srand(time(0));
	char Array[10][10];
	char base[] = { '*', ' ' };
	for (int i = 0; i < 100; i++) {
		char* pArray = &Array[0][0];
		*(pArray + i) = base[rand() % 2];
	}
stop
//Подсказка 1: для генерации случайных чисел используйте функцию
//стандартной библиотеки - rand() (<cstdlib>)
//Можно с помощью генератора случайных чисел  и оператора % получать значения 0 и 1,
// а в массив помещать соответственно '_' и '*'.


//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
//чисел являются «псевдослучайными», то есть при двух последовательных запусках
//приложения Вы получаете две одинаковые последовательности значений.
//Для того чтобы генерируемые "случайные" значения были разными при каждом
//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
//и time() (<ctime>).
//Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
//Функция time() задает эту точку отсчета, считывая текущее время
//srand( time( 0 ) );

//Замечание: в программе запускать функцию srand()  достаточно один раз 


//В каждой строке "сдвиньте звездочки" в начало строки, например:
//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
for (int i = 0; i < 10; i++) {
	for (int j = 0; j < 10; j++) {
		std::cout << Array[i][j] << ' ';
	}
	std::cout << std::endl;
}
std::cout << "____________________________________" << std::endl;
for (int i = 0; i < 10; i++) {
	int left = 0;
	int right = 9;
	for (int j = 0; j < 9; j++) {
		if (left < right) {
			if (Array[i][left] == ' ') {
				if (Array[i][right] == '*') {
					char tmp = Array[i][left];
					Array[i][left] = Array[i][right];
					Array[i][right] = tmp;
					left++;
					right--;
				}
				else { right--; }
			}
			else { left++; }
		}
		else { break; }
	}
}
//и распечатайте массив по строкам - "постройте распределение"
for (int i = 0; i < 10; i++) {
	for (int j = 0; j < 10; j++) {
		std::cout << Array[i][j] << ' ';
	}
	std::cout << std::endl;
}
stop
std::cout << "____________________________________" << std::endl;


// б) Модифицируйте предыдущее задание следующим способом:
//После заполнения массива с помощью генератора случайных чисел
//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
//"распределение"
char Arrayb[10][10];

for (int i = 0; i < 100; i++) {
	char* pArray = &Arrayb[0][0];
	*(pArray + i) = base[rand() % 2];
}
for (int i = 0; i < 10; i++) {
	for (int j = 0; j < 10; j++) {
		std::cout << Arrayb[i][j] << ' ';
	}
	std::cout << std::endl;
}
std::cout << "____________________________________" << std::endl;
for (int i = 0; i < 10; i++) {
	int top = 0;
	int bottom = 9;
	for (int j = 0; j < 9; j++) {
		if (top < bottom) {
			if (Arrayb[top][i] == '*') {
				if (Arrayb[bottom][i] == ' ') {
					char tmp = Arrayb[top][i];
					Arrayb[top][i] = Arrayb[bottom][i];
					Arrayb[bottom][i] = tmp;
					top++;
					bottom--;
				}
				else { bottom--; }
			}
			else { top++; }
		}
		else { break; }
	}
}
for (int i = 0; i < 10; i++) {
	for (int j = 0; j < 10; j++) {
		std::cout << Arrayb[i][j] << ' ';
	}
	std::cout << std::endl;
}
std::cout << "____________________________________" << std::endl;
stop
	}
	///////////////////////////////////////////////////////////////
	//			Динамическое выделение памяти                    //
	///////////////////////////////////////////////////////////////
	//Задание 5.
		////Задание 5а.Создайте ДИНАМИЧЕСКИЙ двухмерный массив с размерностями,
		//вычисляемыми в процессе выполнения программы - N*M.
		//Задайте значения элементов помощью генератора случайных чисел.
	{int N = 5;
	int M = 10;
	int* dynArr = new int[N * M];
	for (int i = 0; i < (N * M); i++) {
		*(dynArr + i) = rand() % 100;
	}
	stop


		//Задание 5б. В сформированном массиве отсортируйте каждую строку по
		//убыванию значений. Используйте сортировку "выбором"
		for (int k = 0; k < N; k++) {
			for (int i = k * M; i < ((k + 1) * M - 1); i++) {
				int min = i; // запоминаем индекс текущего элемента
				// ищем минимальный элемент чтобы поместить на место i-ого
				for (int j = (i + 1); j < (k + 1) * M; j++)  // для остальных элементов после i-ого
				{
					if (dynArr[j] > dynArr[min]) // если элемент меньше минимального,
						min = j;       // запоминаем его индекс в min
				}
				int temp = dynArr[i];      // меняем местами i-ый и минимальный элементы
				dynArr[i] = dynArr[min];
				dynArr[min] = temp;
			}
		}
	stop
		for (int i = 0; i < N; i++) {
			for (int j = i * M; j < (i + 1) * M; j++) {
				std::cout << dynArr[j] << ' ';
			}
			std::cout << std::endl;
		}
	stop


		//Задание 5в. Объявите одномерный массив размерностью N.
		//Сформируйте значение i-ого элемента одномерного массива  
		//равным среднему значению элементов i-ой строки
		//двухмерного массива
		double* dynAver = new double[N];
	for (int i = 0; i < N; i++) {
		dynAver[i] = 0;
		for (int j = i * M; j < (i + 1) * M; j++) {
			dynAver[i]+=dynArr[j];
		}
		dynAver[i] /= M;
		}
	for (int i = 0; i < N; i++) {
		std::cout << dynAver[i] << std::endl;
	}
	
	stop
		//Подсказка - не забудьте освободить память!
	delete[] dynArr;
	dynArr = 0;
	delete[] dynAver;
	dynAver = 0;
	}
/////////////////////////////////////////////////////////////////////////////
//Задание 6. 
	//Реализуйте задание №2, используя не встроенные, а ДИНАМИЧЕСКИЕ массивы (массив?).
	// Важно! 
	//Так как строки могут быть разной длины, /эффективным решением было бы 
	//отводить под каждую строку ровно столько байтов, сколько требуется для ее хранения.
	//
	//Для того, чтобы определить длину введенной строки можно воспользоваться 
	//функцией strlen 
	//size_t strlen(char const* _Str);
	
	//При этом значение количества строк сформируйте с помощью потока ввода
	{std::cout << "Enter the number of words" << std::endl;
	int nStringNumber = 0;
	std::cin >> nStringNumber;
	char STOP_STRING[] = { "*" };
	char** dynArr = new char* [nStringNumber];
	int str = 0;
	for (str ; str < nStringNumber; str++) {
		char Input[80] = {0};
		std::cout << "Please enter the next word and press ENTER" << std::endl;
		std::cin >> Input;
		if (strcmp(Input, STOP_STRING) == 0) { break; };
		size_t lenght = strlen(Input)+1;
		dynArr[str] = new char[lenght];
		strcpy(dynArr[str], Input);
		//memcpy(dynArr[i], Input, lenght);
		stop

	}
	for (int i = 0; i < str; i++) {
		for (int j = 0; j < (str - 1); j++) {
			int res = strcmp(dynArr[j], dynArr[j + 1]);
			if (res > 0) {
				char* bcPointers = dynArr[j]; // создали дополнительную переменную
				dynArr[j] = dynArr[j + 1]; // меняем местами
				dynArr[j + 1] = bcPointers; // значения элементов
			}
		}
	}
	for (int i = 0; i < str; i++) {
		std::cout << dynArr[i] << std::endl;
	}
	stop
	for (int i = 0; i < str; i++) {
			delete[] dynArr[i];
		}
		delete[] dynArr;
		dynArr = 0;
	}
	//Цикл ввода строк:

	// Для ввода строки нужно использовать буфер "достаточного" размера. 
	// В качестве такого буфера обычно используется встроенный массив.
	// Для того, чтобы введенную строку  скопировать из буфера в массив  строк,
	// можно воспользоваться функцией strcpy
	//char* strcpy_s(	char* _Dest,  char const* _Source);
	//  или
	//errno_t strcpy_s(char* _Dest, size_t  _SizeInBytes, char const* _Source); 
	//где _SizeInBytes - размер "приемного" буфера.
	//Замечание: 
	//скорее всего, при компиляции Вы получите следующую ошибку:
	//Severity	Code	Description	Project	File	Line	Suppression State
	//	Error	C4996	'strcpy': This function or variable may be unsafe.
	//Consider using strcpy_s instead.To disable deprecation, use _CRT_SECURE_NO_WARNINGS.
	
	//Это происходит потому, что функция strcpy считается небезопасной.
	
	//Для того, чтобы пользоваться функцией strcpy, а не strcpy_s, можно
	//  - либо объявить макрос #define _CRT_SECURE_NO_WARNINGS   (обязательно ДО всех #include !!!!!)
	//- либо установить режим без доп. проверки на безопасность Properties->C/C++ ->General->SDL checs -> No
	

	//Цикл сортировки строк по методу "всплывающего пузырька" в
	//порядке возрастания кода первого символа





	//Освобождение занятой памяти:




	return 0; 
}